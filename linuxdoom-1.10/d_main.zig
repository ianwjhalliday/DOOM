const c = @cImport({
    @cInclude("stdio.h");
    @cInclude("stdlib.h");
    @cInclude("unistd.h");
    @cInclude("sys/Stat.h");
    @cInclude("doomdef.h");
    @cInclude("doomstat.h");
    @cInclude("dstrings.h");
    @cInclude("d_event.h");
    @cInclude("d_net.h");
    @cInclude("d_player.h");
    @cInclude("f_wipe.h");
    @cInclude("g_game.h");
    @cInclude("r_main.h");
    @cInclude("s_sound.h");
    @cInclude("sounds.h");
    @cInclude("v_video.h");
});

extern fn G_Responder(ev: *c.event_t) bool;
extern fn M_Responder(ev: *c.event_t) bool;
extern fn W_CheckNumForName(name: [*c]const u8) c_int;

extern fn AM_Drawer() void;
extern fn F_Drawer() void;
extern fn HU_Drawer() void;
extern fn HU_Erase() void;
extern fn I_UpdateNoBlit() void;
extern fn M_Drawer() void;
extern fn R_FillBackScreen() void;
extern fn R_DrawViewBorder() void;
extern fn ST_Drawer(fullscreen: bool, refresh: bool) void;
extern fn WI_Drawer() void;

extern fn NetUpdate() void;
extern fn I_FinishUpdate() void;

extern fn I_SetPalette(pal: [*]u8) void;
extern fn W_CacheLumpName(name: [*:0]const u8, tag: Z_Tag) [*]u8;

extern fn G_BeginRecording() void;
extern fn I_InitGraphics() void;
extern fn I_StartFrame() void;
extern fn I_StartTic() void;
extern fn M_Ticker() void;
extern fn G_Ticker() void;
extern fn TryRunTics() void;
extern fn I_UpdateSound() void;
extern fn I_SubmitSound() void;

extern fn G_BuildTiccmd(*c.ticcmd_t) void;

// TODO: import M_CheckParm when this will no longer cause a double export
extern fn M_CheckParm(check: [*:0]const u8) c_int;

const std = @import("std");
const Z_Tag = @import("z_zone.zig").Z_Tag;
const i_system = @import("i_system.zig");
const I_Init = i_system.I_Init;
const I_GetTime = i_system.I_GetTime;
const I_Error = i_system.I_Error;

const MAXWADFILES = 20;

var wadfiles = [_]?[*:0]const u8{null} ** MAXWADFILES;

export var devparm: bool = false; // started game with -devparm
export var nomonsters: bool = false; // checkparm of -nomonsters
export var respawnparm: bool = false; // checkparm of -respawn
export var fastparm: bool = false; // checkparm of -fast

export var singletics: bool = false; // debug flag to cancel adaptiveness

extern var inhelpscreens: bool;

export var startskill: c.skill_t = 0;
export var startepisode: c_int = 0;
export var startmap: c_int = 0;
export var autostart: bool = false;

export var debugfile: ?*c.FILE = null;

export var advancedemo: bool = false;

var wadfile: [1023:0]u8 = undefined; // primary wad file
export var basedefault: [1023:0]u8 = undefined; // default file

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
export var events: [c.MAXEVENTS]c.event_t = undefined;
export var eventhead: usize = 0;
export var eventtail: usize = 0;

//
// D_PostEvent
// Called by the I/O functions when input is detected
//
pub export fn D_PostEvent(ev: *c.event_t) void {
    events[eventhead] = ev.*;
    eventhead = (1 + eventhead) % c.MAXEVENTS;
}

//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
pub export fn D_ProcessEvents() void {
    // IF STORE DEMO, DO NOT ACCEPT INPUT
    if (c.gamemode == c.commercial and W_CheckNumForName(@constCast("map01")) < 0)
        return;

    while (eventtail != eventhead) : (eventtail = (1 + eventtail) % c.MAXEVENTS) {
        const ev = &events[eventtail];
        if (M_Responder(ev))
            continue; // menu ate the event
        _ = G_Responder(ev);
    }
}

//
// D_Display
//  draw current display, possibly wiping it from the previous
//

// wipegamestate can be set to -1 to force a wipe on the next draw
export var wipegamestate: c.gamestate_t = c.GS_DEMOSCREEN;
extern var setsizeneeded: bool;
extern var showMessages: c_int;
extern var nodrawers: bool;
extern var automapactive: bool;
extern var menuactive: bool;
extern var viewactive: bool;
extern var paused: bool;
extern fn R_ExecuteSetViewSize() void;

fn D_Display() void {
    const S = struct {
        var viewactivestate = false;
        var menuactivestate = false;
        var inhelpscreensstate = false;
        var fullscreen = false;
        // TODO: Add an Invalid value to gamestate_t
        var oldgamestate: c.gamestate_t = std.math.maxInt(c.gamestate_t);
        var borderdrawcount: c_int = 0;
    };

    if (nodrawers) {
        return; // for comparative timing / profiling
    }

    var redrawsbar = false;

    // change the view size if needed
    if (setsizeneeded) {
        R_ExecuteSetViewSize();
        S.oldgamestate = std.math.maxInt(c.gamestate_t); // force background redraw
        S.borderdrawcount = 3;
    }

    // save the current screen if about to wipe
    var wipe = false;
    if (c.gamestate != wipegamestate) {
        wipe = true;
        _ = c.wipe_StartScreen(0, 0, c.SCREENWIDTH, c.SCREENHEIGHT);
    }

    if (c.gamestate == c.GS_LEVEL and c.gametic != 0)
        HU_Erase();

    // do buffered drawing
    switch (c.gamestate) {
        c.GS_LEVEL => blk: {
            if (c.gametic == 0)
                break :blk;
            if (automapactive)
                AM_Drawer();
            if (wipe or (c.viewheight != 200 and S.fullscreen))
                redrawsbar = true;
            if (S.inhelpscreensstate and !inhelpscreens)
                redrawsbar = true; // just put away the help screen
            ST_Drawer(c.viewheight == 200, redrawsbar);
            S.fullscreen = c.viewheight == 200;
        },

        c.GS_INTERMISSION => {
            WI_Drawer();
        },

        c.GS_FINALE => {
            F_Drawer();
        },

        c.GS_DEMOSCREEN => {
            D_PageDrawer();
        },

        else => {}, // TODO: Convert gamestate_t to Zig enum and eliminate this else
    }

    // draw buffered stuff to screen
    I_UpdateNoBlit();

    // draw the view directly
    if (c.gamestate == c.GS_LEVEL and !automapactive and c.gametic != 0)
        c.R_RenderPlayerView(&c.players[@intCast(usize, c.displayplayer)]);

    if (c.gamestate == c.GS_LEVEL and c.gametic != 0)
        HU_Drawer();

    // clean up border stuff
    if (c.gamestate != S.oldgamestate and c.gamestate != c.GS_LEVEL)
        I_SetPalette(W_CacheLumpName("PLAYPAL", .Cache));

    // see if the border needs to be initially drawn
    if (c.gamestate == c.GS_LEVEL and S.oldgamestate != c.GS_LEVEL) {
        S.viewactivestate = false; // view was not active
        R_FillBackScreen(); // draw the pattern into the back screen
    }

    // see if the border needs to be updated to the screen
    if (c.gamestate == c.GS_LEVEL and !automapactive and c.scaledviewwidth != 320) {
        if (menuactive or S.menuactivestate or !S.viewactivestate)
            S.borderdrawcount = 3;
        if (S.borderdrawcount != 0) {
            R_DrawViewBorder(); // erase old menu stuff
            S.borderdrawcount -= 1;
        }
    }

    S.menuactivestate = menuactive;
    S.viewactivestate = viewactive;
    S.inhelpscreensstate = inhelpscreens;
    wipegamestate = c.gamestate;
    S.oldgamestate = c.gamestate;

    // draw pause pic
    if (paused) {
        const y = if (automapactive) 4 else c.viewwindowy + 4;
        c.V_DrawPatchDirect(c.viewwindowx + @divTrunc(c.scaledviewwidth - 68, 2), y, 0, @ptrCast(*c.patch_t, @alignCast(@alignOf(c.patch_t), W_CacheLumpName("M_PAUSE", .Cache))));
    }

    // menus go directly to the screen
    M_Drawer(); // menu is drawn even on top of everything
    NetUpdate(); // send out any new accumulation

    // normal update
    if (!wipe) {
        I_FinishUpdate(); // page flip or blit buffer
        return;
    }

    // wipe update
    _ = c.wipe_EndScreen(0, 0, c.SCREENWIDTH, c.SCREENHEIGHT);

    var wipestart = I_GetTime() - 1;
    var done = false;

    while (!done) {
        var nowtime: c_int = undefined;
        var tics: c_int = 0;
        while (tics == 0) {
            nowtime = I_GetTime();
            tics = nowtime - wipestart;
        }
        wipestart = nowtime;
        done = 0 != c.wipe_ScreenWipe(c.wipe_Melt, 0, 0, c.SCREENWIDTH, c.SCREENHEIGHT, tics);
        I_UpdateNoBlit();
        M_Drawer(); // menu is drawn even on top of wipes
        I_FinishUpdate(); // page flip or blit buffer
    }
}

//
//  D_DoomLoop
//
extern var demorecording: bool;

fn D_DoomLoop() noreturn {
    if (demorecording) {
        G_BeginRecording();
    }

    // TODO: This parm check should be in `D_DoomMain()`
    if (M_CheckParm("-debugfile") != 0) {
        var buffer: [20]u8 = undefined;
        const filename = std.fmt.bufPrintZ(&buffer, "debug{}.txt", .{c.consoleplayer}) catch unreachable;
        _ = c.printf("debug output to: %s\n", filename.ptr);
        debugfile = c.fopen(filename, "w");
    }

    I_InitGraphics();

    while (true) {
        // frame syncronous IO operations
        I_StartFrame();

        // process one or more tics
        if (singletics) {
            I_StartTic();
            D_ProcessEvents();
            G_BuildTiccmd(&c.netcmds[@intCast(usize, c.consoleplayer)][@intCast(usize, c.maketic) % c.BACKUPTICS]);
            if (advancedemo)
                D_DoAdvanceDemo();
            M_Ticker();
            G_Ticker();
            c.gametic += 1;
            c.maketic += 1;
        } else {
            TryRunTics(); // will run at least one tic
        }

        c.S_UpdateSounds(c.players[@intCast(usize, c.consoleplayer)].mo); // move positional sounds

        // Update display, next frame, with current state.
        D_Display();

        I_UpdateSound();
        I_SubmitSound();
    }
}

//
//  DEMO LOOP
//
var demosequence: usize = 0;
var pagetic: c_int = 0;
var pagename: [*:0]const u8 = undefined;

//
// D_PageTicker
// Handles timing for warped projection
//
export fn D_PageTicker() void {
    pagetic -= 1;
    if (pagetic < 0) {
        D_AdvanceDemo();
    }
}

//
// D_PageDrawer
//
fn D_PageDrawer() void {
    c.V_DrawPatch(0, 0, 0, @ptrCast(*c.patch_t, @alignCast(@alignOf(c.patch_t), W_CacheLumpName(pagename, .Cache))));
}

//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
export fn D_AdvanceDemo() void {
    advancedemo = true;
}

//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
extern var usergame: bool;
export fn D_DoAdvanceDemo() void {
    c.players[@intCast(usize, c.consoleplayer)].playerstate = c.PST_LIVE; // not reborn
    advancedemo = false;
    usergame = false; // no save / end game here
    paused = false;
    c.gameaction = c.ga_nothing;

    switch (demosequence) {
        0 => {
            pagetic = if (c.gamemode == c.commercial) 35 * 11 else 170;
            c.gamestate = c.GS_DEMOSCREEN;
            pagename = "TITLEPIC";
            c.S_StartMusic(if (c.gamemode == c.commercial) c.mus_dm2ttl else c.mus_intro);
        },
        1 => {
            c.G_DeferedPlayDemo(@constCast("demo1"));
        },
        2 => {
            pagetic = 200;
            c.gamestate = c.GS_DEMOSCREEN;
            pagename = "CREDIT";
        },
        3 => {
            c.G_DeferedPlayDemo(@constCast("demo2"));
        },
        4 => {
            c.gamestate = c.GS_DEMOSCREEN;
            if (c.gamemode == c.commercial) {
                pagetic = 35 * 11;
                pagename = "TITLEPIC";
                c.S_StartMusic(c.mus_dm2ttl);
            } else {
                pagetic = 200;
                pagename = if (c.gamemode == c.retail) "CREDIT" else "HELP2";
            }
        },
        5 => {
            c.G_DeferedPlayDemo(@constCast("demo3"));
        },
        // THE DEFINITIVE DOOM Special Edition demo
        6 => {
            c.G_DeferedPlayDemo(@constCast("demo4"));
        },
        else => {}, // TODO: Make a zig enum and remove this else arm
    }

    demosequence += 1;
    demosequence %= if (c.gamemode == c.retail) 7 else 6;
}

//
// D_StartTitle
//
export fn D_StartTitle() void {
    c.gameaction = c.ga_nothing;
    demosequence = 0;
    D_AdvanceDemo();
}

//
// D_AddFile
//
fn D_AddFile(file: [*:0]const u8) void {
    var numwadfiles: usize = 0;
    while (wadfiles[numwadfiles] != null) {
        numwadfiles += 1;
    }

    const len = c.strlen(file);
    var newfile = std.heap.raw_c_allocator.alloc(u8, len + 1) catch unreachable;
    _ = c.strcpy(newfile.ptr, file);

    wadfiles[numwadfiles] = newfile[0..len :0];
}

//
// IdentifyVersion
// Checks availability of IWAD files by name,
// to determine whether registered/commercial features
// should be executed (notably loading PWAD's).
//
fn IdentifyVersion() void {
    // TODO: Use fmt to build these strings and make them const instead of var
    // Use raw_c_allocator as well.
    var doom1wad: [*c]u8 = undefined;
    var doomwad: [*c]u8 = undefined;
    var doomuwad: [*c]u8 = undefined;
    var doom2wad: [*c]u8 = undefined;

    var doom2fwad: [*c]u8 = undefined;
    var plutoniawad: [*c]u8 = undefined;
    var tntwad: [*c]u8 = undefined;

    var home: [*c]u8 = undefined;
    const doomwaddir = std.mem.span(std.c.getenv("DOOMWADDIR") orelse ".");

    // Commercial.
    doom2wad = @ptrCast([*c]u8, std.c.malloc(doomwaddir.len + 1 + 9 + 1) orelse unreachable);
    _ = c.sprintf(doom2wad, "%s/doom2.wad", doomwaddir.ptr);

    // Retail.
    doomuwad = @ptrCast([*c]u8, std.c.malloc(doomwaddir.len + 1 + 8 + 1) orelse unreachable);
    _ = c.sprintf(doomuwad, "%s/doomu.wad", doomwaddir.ptr);

    // Registered.
    doomwad = @ptrCast([*c]u8, std.c.malloc(doomwaddir.len + 1 + 8 + 1) orelse unreachable);
    _ = c.sprintf(doomwad, "%s/doom.wad", doomwaddir.ptr);

    // Shareware.
    doom1wad = @ptrCast([*c]u8, std.c.malloc(doomwaddir.len + 1 + 9 + 1) orelse unreachable);
    _ = c.sprintf(doom1wad, "%s/doom1.wad", doomwaddir.ptr);

    plutoniawad = @ptrCast([*c]u8, std.c.malloc(doomwaddir.len + 1 + 12 + 1) orelse unreachable);
    _ = c.sprintf(plutoniawad, "%s/plutonia.wad", doomwaddir.ptr);

    tntwad = @ptrCast([*c]u8, std.c.malloc(doomwaddir.len + 1 + 9 + 1) orelse unreachable);
    _ = c.sprintf(tntwad, "%s/tnt.wad", doomwaddir.ptr);

    // French stuff.
    doom2fwad = @ptrCast([*c]u8, std.c.malloc(doomwaddir.len + 1 + 10 + 1) orelse unreachable);
    _ = c.sprintf(doom2fwad, "%s/doom2f.wad", doomwaddir.ptr);

    home = std.c.getenv("HOME");
    if (home == null) {
        I_Error("Please set $HOME to your home directory");
    }
    _ = c.sprintf(&basedefault, "%s/.doomrc", home);

    if (M_CheckParm("-shdev") != 0) {
        c.gamemode = c.shareware;
        devparm = true;
        D_AddFile(c.DEVDATA ++ "doom1.wad");
        D_AddFile(c.DEVMAPS ++ "data_se/texture1.lmp");
        D_AddFile(c.DEVMAPS ++ "data_se/pnames.lmp");
        _ = c.strcpy(&basedefault, c.DEVDATA ++ "default.cfg");
        return;
    }

    if (M_CheckParm("-regdev") != 0) {
        c.gamemode = c.registered;
        devparm = true;
        D_AddFile(c.DEVDATA ++ "doom.wad");
        D_AddFile(c.DEVMAPS ++ "data_se/texture1.lmp");
        D_AddFile(c.DEVMAPS ++ "data_se/texture2.lmp");
        D_AddFile(c.DEVMAPS ++ "data_se/pnames.lmp");
        _ = c.strcpy(&basedefault, c.DEVDATA ++ "default.cfg");
        return;
    }

    if (M_CheckParm("-comdev") != 0) {
        c.gamemode = c.commercial;
        devparm = true;
        D_AddFile(c.DEVDATA ++ "doom2.wad");

        D_AddFile(c.DEVMAPS ++ "cdata/texture1.lmp");
        D_AddFile(c.DEVMAPS ++ "cdata/pnames.lmp");
        _ = c.strcpy(&basedefault, c.DEVDATA ++ "default.cfg");
        return;
    }

    if (0 == c.access(doom2fwad, c.R_OK)) {
        c.gamemode = c.commercial;
        // C'est ridicule!
        // Let's handle languages in config files, okay?
        c.language = c.french;
        _ = c.printf("French version\n");
        D_AddFile(doom2fwad);
        return;
    }

    if (0 == c.access(doom2wad, c.R_OK)) {
        c.gamemode = c.commercial;
        D_AddFile(doom2wad);
        return;
    }

    if (0 == c.access(plutoniawad, c.R_OK)) {
        c.gamemode = c.commercial;
        D_AddFile(plutoniawad);
        return;
    }

    if (0 == c.access(tntwad, c.R_OK)) {
        c.gamemode = c.commercial;
        D_AddFile(tntwad);
        return;
    }

    if (0 == c.access(doomuwad, c.R_OK)) {
        c.gamemode = c.retail;
        D_AddFile(doomuwad);
        return;
    }

    if (0 == c.access(doomwad, c.R_OK)) {
        c.gamemode = c.registered;
        D_AddFile(doomwad);
        return;
    }

    if (0 == c.access(doom1wad, c.R_OK)) {
        c.gamemode = c.shareware;
        D_AddFile(doom1wad);
        return;
    }

    _ = c.printf("Game mode indeterminate.\n");
    c.gamemode = c.indetermined;

    // We don't abort. Let's see what the PWAD contains.
    //exit(1);
    //I_Error ("Game mode indeterminate\n");
}

//
// Find a Response File
//

// TODO: Import myarg variables instead of extern.
// Or better yet use `myargs`.
extern var myargc: c_int;
extern var myargv: [*c][*c]u8;

fn FindResponseFile() void {
    const MAXARGVS = 100;

    for (1..@intCast(usize, myargc)) |i| {
        if (myargv[i][0] == '@') {
            // TODO: Extract this body to a func in m_argv.zig
            // (and, of course, make it more zig idiomatic)

            // READ THE RESPONSE FILE INTO MEMORY
            const handle = c.fopen(@ptrCast([*:0]const u8, &myargv[i][1]), "rb");
            if (handle == null) {
                I_Error("\nNo such response file!");
            }
            _ = c.printf("Found response file %s!\n", &myargv[i][1]);
            _ = c.fseek(handle, 0, c.SEEK_END);
            const size = c.ftell(handle);
            _ = c.fseek(handle, 0, c.SEEK_SET);
            const file = std.c.malloc(@intCast(usize, size));
            _ = c.fread(file, @intCast(usize, size), 1, handle);
            _ = c.fclose(handle);

            // KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG
            const originalargv = myargv;

            myargv = @ptrCast([*c][*c]u8, @alignCast(@alignOf([*c][*c]u8), std.c.malloc(@sizeOf([*c]u8) * MAXARGVS) orelse unreachable));
            @memset(myargv[0 .. MAXARGVS - 1], 0);

            const infile = @ptrCast([*]u8, file);
            var indexinfile: usize = 0;

            while (indexinfile < i) : (indexinfile += 1) {
                myargv[indexinfile] = originalargv[indexinfile];
            }

            var k: usize = 0;
            while (k < size) {
                myargv[indexinfile] = infile + k;
                indexinfile += 1;

                while (k < size and (infile[k] >= ' ' + 1 and infile[k] <= 'z')) {
                    k += 1;
                }
                infile[k] = 0;
                while (k < size and (infile[k] <= ' ' or infile[k] > 'z')) {
                    k += 1;
                }
            }

            k = i + 1;
            while (k < myargc) : ({
                k += 1;
                indexinfile += 1;
            }) {
                myargv[indexinfile] = originalargv[k];
            }
            myargc = @intCast(c_int, indexinfile);

            // DISPLAY ARGS
            _ = c.printf("%d command-line args:\n", myargc);
            k = 1;
            while (k < myargc) : (k += 1) {
                _ = c.printf("%s\n", myargv[k]);
            }

            break;
        }
    }
}

//
// D_DoomMain
//
extern var modifiedgame: bool;
extern var forwardmove: [2]c_int;
extern var sidemove: [2]c_int;
extern var deathmatch: c_short;
extern var statcopy: *anyopaque;
extern var singledemo: bool;

extern fn V_Init() void;
extern fn M_LoadDefaults() void; // load before initing other systems
extern fn Z_Init() void;
extern fn W_InitMultipleFiles(filenames: [*c][*c]const u8) void;
extern fn M_Init() void;
extern fn R_Init() void;
extern fn P_Init() void;
extern fn D_CheckNetGame() void;
extern fn S_Init(sfxVolume: c_int, musicVolume: c_int) void;
extern fn HU_Init() void;
extern fn ST_Init() void;

pub fn D_DoomMain() noreturn {
    FindResponseFile();

    IdentifyVersion();

    const stdout = c.fdopen(2, "w");
    defer _ = c.fflush(stdout);
    defer _ = c.fclose(stdout);

    c.setbuf(stdout, null);
    modifiedgame = false;

    nomonsters = M_CheckParm("-nomonsters") != 0;
    respawnparm = M_CheckParm("-respawn") != 0;
    fastparm = M_CheckParm("-fast") != 0;
    devparm = M_CheckParm("-devparm") != 0;
    if (M_CheckParm("-altdeath") != 0) {
        deathmatch = 2;
    } else if (M_CheckParm("-deathmatch") != 0) {
        deathmatch = 1;
    }

    const title = switch (c.gamemode) {
        c.retail => std.fmt.comptimePrint("                         " ++
            "The Ultimate DOOM Startup v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
        c.shareware => std.fmt.comptimePrint("                            " ++
            "DOOM Shareware Startup v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
        c.registered => std.fmt.comptimePrint("                            " ++
            "DOOM Registered Startup v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
        c.commercial => std.fmt.comptimePrint("                         " ++
            "DOOM 2: Hell on Earth v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
        else => std.fmt.comptimePrint("                     " ++
            "Public DOOM - v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
    };

    _ = c.printf("%s\n", title.ptr);

    if (devparm)
        _ = c.printf(c.D_DEVSTR);

    if (M_CheckParm("-cdrom") != 0) {
        _ = c.printf(c.D_CDROM);
        _ = c.mkdir("c:\\doomdata", 0);
        _ = c.strcpy(&basedefault, "c:/doomdata/default.cfg");
    }

    // turbo option
    var p = @intCast(usize, M_CheckParm("-turbo"));
    if (p != 0) {
        var scale: usize = 200;

        if (p < myargc - 1) {
            scale = @intCast(usize, c.atoi(myargv[@intCast(usize, p) + 1]));
        }
        if (scale < 10) {
            scale = 10;
        }
        if (scale > 400) {
            scale = 400;
        }
        _ = c.printf("turbo scale: %i%%\n", scale);
        forwardmove[0] = forwardmove[0] * @intCast(c_int, scale / 100);
        forwardmove[1] = forwardmove[1] * @intCast(c_int, scale / 100);
        sidemove[0] = sidemove[0] * @intCast(c_int, scale / 100);
        sidemove[1] = sidemove[1] * @intCast(c_int, scale / 100);
    }

    var file: [255:0]u8 = undefined;

    // add any files specified on the command line with -file wadfile
    // to the wad list
    //
    // convenience hack to allow -wart e m to add a wad file
    // prepend a tilde to the filename so wadfile will be reloadable
    p = @intCast(usize, M_CheckParm("-wart"));
    if (p != 0) {
        myargv[p][4] = 'p'; // big hack, change to -warp

        // Map name handling.
        switch (c.gamemode) {
            c.shareware, c.retail, c.registered => {
                _ = c.sprintf(&file, "~" ++ c.DEVMAPS ++ "E%cM%c.wad", myargv[p + 1][0], myargv[p + 2][0]);
                _ = c.printf("Warping to Episode %s, Map %s.\n", myargv[p + 1], myargv[p + 2]);
            },

            // c.commercial,
            else => {
                const num = c.atoi(myargv[p + 1]);
                if (num < 10) {
                    _ = c.sprintf(&file, "~" ++ c.DEVMAPS ++ "cdata/map0%i.wad", num);
                } else {
                    _ = c.sprintf(&file, "~" ++ c.DEVMAPS ++ "cdata/map%i.wad", num);
                }
            },
        }
        D_AddFile(&file);
    }

    p = @intCast(usize, M_CheckParm("-file"));
    if (p != 0) {
        // the parms after p are wadfile/lump names,
        // until end of parms or another - preceded parm
        modifiedgame = true; // homebrew levels
        p += 1;
        while (p != myargc and myargv[p][0] != '-') : (p += 1) {
            D_AddFile(myargv[p]);
        }
    }

    p = @intCast(usize, M_CheckParm("-playdemo"));

    if (p == 0) {
        p = @intCast(usize, M_CheckParm("-timedemo"));
    }

    if (p != 0 and p < myargc - 1) {
        _ = c.sprintf(&file, "%s.lmp", myargv[p + 1]);
        D_AddFile(&file);
        _ = c.printf("Playing demo %s.lmp.\n", myargv[p + 1]);
    }

    // get skill / episode / map from parms
    startskill = c.sk_medium;
    startepisode = 1;
    startmap = 1;
    autostart = false;

    p = @intCast(usize, M_CheckParm("-skill"));
    if (p != 0 and p < myargc - 1) {
        startskill = myargv[p + 1][0] - '1';
        autostart = true;
    }

    p = @intCast(usize, M_CheckParm("-episode"));
    if (p != 0 and p < myargc - 1) {
        startepisode = myargv[p + 1][0] - '0';
        startmap = 1;
        autostart = true;
    }

    p = @intCast(usize, M_CheckParm("-timer"));
    if (p != 0 and p < myargc - 1 and deathmatch != 0) {
        const time = c.atoi(myargv[p + 1]);
        _ = c.printf("Levels will end after %d minute", time);
        if (time > 1)
            _ = c.printf("s");
        _ = c.printf(".\n");
    }

    p = @intCast(usize, M_CheckParm("-avg"));
    if (p != 0 and p < myargc - 1 and deathmatch != 0)
        _ = c.printf("Austin Virtual Gaming: Levels will end after 20 minutes\n");

    p = @intCast(usize, M_CheckParm("-warp"));
    if (p != 0 and p < myargc - 1) {
        if (c.gamemode == c.commercial) {
            startmap = c.atoi(myargv[p + 1]);
        } else {
            startepisode = myargv[p + 1][0] - '0';
            startmap = myargv[p + 2][0] - '0';
        }
        autostart = true;
    }

    // init subsystems
    _ = c.printf("V_Init: allocate screens.\n");
    V_Init();

    _ = c.printf("M_LoadDefaults: Load system defaults.\n");
    M_LoadDefaults(); // load before initing other systems

    _ = c.printf("Z_Init: Init zone memory allocation daemon. \n");
    Z_Init();

    _ = c.printf("W_Init: Init WADfiles.\n");
    W_InitMultipleFiles(&wadfiles);

    // Check for -file in shareware
    if (modifiedgame) {
        // These are the lumps that will be checked in IWAD,
        // if any one is not present, execution will be aborted.
        var names = [_][:0]const u8{ "e2m1", "e2m2", "e2m3", "e2m4", "e2m5", "e2m6", "e2m7", "e2m8", "e2m9", "e3m1", "e3m3", "e3m3", "e3m4", "e3m5", "e3m6", "e3m7", "e3m8", "e3m9", "dphoof", "bfgga0", "heada1", "cybra1", "spida1d1" };

        if (c.gamemode == c.shareware) {
            I_Error("\nYou cannot -file with the shareware version. Register!");
        }

        // Check for fake IWAD with right name,
        // but w/o all the lumps of the registered version.
        if (c.gamemode == c.registered) {
            var i: usize = 0;
            _ = i;
            for (names) |name| {
                if (W_CheckNumForName(name) < 0) {
                    I_Error("\nThis is not the registered version.");
                }
            }
        }
    }

    // Iff additonal PWAD files are used, print modified banner
    if (modifiedgame) {
        _ = c.printf("===========================================================================\n" ++
            "ATTENTION:  This version of DOOM has been modified.  If you would like to\n" ++
            "get a copy of the original game, call 1-800-IDGAMES or see the readme file.\n" ++
            "        You will not receive technical support for modified games.\n" ++
            "                      press enter to continue\n" ++
            "===========================================================================\n");
        _ = c.getchar();
    }

    // Check and print which version is executed.
    switch (c.gamemode) {
        c.shareware, c.indetermined => {
            _ = c.printf("===========================================================================\n" ++
                "                                Shareware!\n" ++
                "===========================================================================\n");
        },
        c.registered, c.retail, c.commercial => {
            _ = c.printf("===========================================================================\n" ++
                "                 Commercial product - do not distribute!\n" ++
                "         Please report software piracy to the SPA: 1-800-388-PIR8\n" ++
                "===========================================================================\n");
        },

        else => unreachable,
    }

    _ = c.printf("M_Init: Init miscellaneous info.\n");
    M_Init();

    _ = c.printf("R_Init: Init DOOM refresh daemon - ");
    R_Init();

    _ = c.printf("\nP_Init: Init Playloop state.\n");
    P_Init();

    _ = c.printf("I_Init: Setting up machine state.\n");
    I_Init();

    _ = c.printf("D_CheckNetGame: Checking network game status.\n");
    D_CheckNetGame();

    _ = c.printf("S_Init: Setting up sound.\n");
    S_Init(c.snd_SfxVolume, c.snd_MusicVolume);

    _ = c.printf("HU_Init: Setting up heads up display.\n");
    HU_Init();

    _ = c.printf("ST_Init: Init status bar.\n");
    ST_Init();

    // check for a driver that wants intermission stats
    p = @intCast(usize, M_CheckParm("-statcopy"));
    if (p != 0 and p < myargc - 1) {
        // for statistics driver
        statcopy = @intToPtr(*anyopaque, @intCast(usize, c.atol(myargv[p + 1])));
        _ = c.printf("External statistics registered.\n");
    }

    // start the apropriate game based on parms
    p = @intCast(usize, M_CheckParm("-record"));

    if (p != 0 and p < myargc - 1) {
        c.G_RecordDemo(myargv[p + 1]);
        autostart = true;
    }

    p = @intCast(usize, M_CheckParm("-playdemo"));
    if (p != 0 and p < myargc - 1) {
        singledemo = true; // quit after one demo
        c.G_DeferedPlayDemo(myargv[p + 1]);
        D_DoomLoop(); // never returns
    }

    p = @intCast(usize, M_CheckParm("-timedemo"));
    if (p != 0 and p < myargc - 1) {
        c.G_TimeDemo(myargv[p + 1]);
        D_DoomLoop(); // never returns
    }

    p = @intCast(usize, M_CheckParm("-loadgame"));
    if (p != 0 and p < myargc - 1) {
        if (M_CheckParm("-cdrom") != 0) {
            _ = c.sprintf(&file, "c:\\doomdata\\" ++ c.SAVEGAMENAME ++ "%c.dsg", myargv[p + 1][0]);
        } else {
            _ = c.sprintf(&file, c.SAVEGAMENAME ++ "%c.dsg", myargv[p + 1][0]);
        }
        c.G_LoadGame(&file);
    }

    if (c.gameaction != c.ga_loadgame) {
        if (autostart or c.netgame != 0) {
            c.G_InitNew(startskill, startepisode, startmap);
        } else {
            D_StartTitle(); // start up intro loop
        }
    }

    D_DoomLoop(); // never returns
}
