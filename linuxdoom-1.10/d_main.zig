const c = @cImport({
    @cInclude("doomstat.h");
    @cInclude("doomtype.h");
    @cInclude("dstrings.h");
    @cInclude("d_event.h");
    @cInclude("d_player.h");
    @cInclude("r_main.h");
    @cInclude("s_sound.h");
    @cInclude("sounds.h");
    @cInclude("v_video.h");
});

extern fn M_Responder(ev: *Event) c.boolean;
extern fn W_CheckNumForName(name: [*c]const u8) c_int;

extern fn AM_Drawer() void;
extern fn F_Drawer() void;
extern fn HU_Drawer() void;
extern fn HU_Erase() void;
extern fn M_Drawer() void;
extern fn R_FillBackScreen() void;
extern fn R_DrawViewBorder() void;
const ST_Drawer = @import("st_stuff.zig").ST_Drawer;
extern fn WI_Drawer() void;

extern fn NetUpdate() void;

extern fn M_Ticker() void;
extern fn G_Ticker() void;
extern fn I_UpdateSound() void;
extern fn I_SubmitSound() void;

const std = @import("std");
const fmt = std.fmt;
const os = std.os;
const M_CheckParm = @import("m_argv.zig").M_CheckParm;
const M_LoadDefaults = @import("m_misc.zig").M_LoadDefaults;
const Z_Tag = @import("z_zone.zig").Z_Tag;

const d_net = @import("d_net.zig");
const D_CheckNetGame = d_net.D_CheckNetGame;
const TryRunTics = d_net.TryRunTics;

const i_system = @import("i_system.zig");
const I_Init = i_system.I_Init;
const I_GetTime = i_system.I_GetTime;
const I_Error = i_system.I_Error;

const i_video = @import("i_video.zig");
const I_InitGraphics = i_video.I_InitGraphics;
const I_StartTic = i_video.I_StartTic;
const I_StartFrame = i_video.I_StartFrame;
const I_UpdateNoBlit = i_video.I_UpdateNoBlit;
const I_FinishUpdate = i_video.I_FinishUpdate;
const I_SetPalette = i_video.I_SetPalette;

const g_game = @import("g_game.zig");
const G_BeginRecording = g_game.G_BeginRecording;
const G_BuildTiccmd = g_game.G_BuildTiccmd;
const G_DeferedPlayDemo = g_game.G_DeferedPlayDemo;
const G_InitNew = g_game.G_InitNew;
const G_LoadGame = g_game.G_LoadGame;
const G_RecordDemo = g_game.G_RecordDemo;
const G_Responder = g_game.G_Responder;
const G_TimeDemo = g_game.G_TimeDemo;
const TicCmd = @import("d_ticcmd.zig").TicCmd;

const w_wad = @import("w_wad.zig");
const W_InitMultipleFiles = w_wad.W_InitMultipleFiles;
const W_CacheLumpName = w_wad.W_CacheLumpName;

const wipe = @import("f_wipe.zig");

const doomdef = @import("doomdef.zig");
const MAXPLAYERS = doomdef.MAXPLAYERS;
const SCREENWIDTH = doomdef.SCREENWIDTH;
const SCREENHEIGHT = doomdef.SCREENHEIGHT;
const GameState = doomdef.GameState;
const Skill = doomdef.Skill;

const MAXWADFILES = 20;

var wadfiles = [_][]const u8{undefined} ** MAXWADFILES;
var numwadfiles: usize = 0;

pub export var devparm: c.boolean = c.false; // started game with -devparm
pub export var nomonsters: c.boolean = c.false; // checkparm of -nomonsters
pub var respawnparm = false;    // checkparm of -respawn
pub export var fastparm: c.boolean = c.false; // checkparm of -fast

pub var singletics = false;     // debug flag to cancel adaptiveness

extern var inhelpscreens: c.boolean;

pub var startskill: Skill = .Medium;
pub var startepisode: c_int = 0;
pub export var startmap: c_int = 0;
pub var autostart = false;

pub export var debugfile: ?*std.c.FILE = null;

pub var advancedemo = false;

// TODO: Convert to zig only pub slice
export var basedefault: [1023:0]u8 = undefined; // default file

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
pub var events: [c.MAXEVENTS]Event = undefined;
pub var eventhead: usize = 0;
pub var eventtail: usize = 0;

pub const EventType = enum(c_int) {
    KeyDown,
    KeyUp,
    Mouse,
    Joystick,
};

pub const Event = extern struct {
    type: EventType,
    data1: c_int,   // keys / mouse/joystick buttons
    data2: c_int,   // mouse/joystick x move
    data3: c_int,   // mouse/joystick y move
};

//
// D_PostEvent
// Called by the I/O functions when input is detected
//
pub export fn D_PostEvent(ev: *const Event) void {
    events[eventhead] = ev.*;
    eventhead = (1 + eventhead) % c.MAXEVENTS;
}

//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
pub fn D_ProcessEvents() void {
    // IF STORE DEMO, DO NOT ACCEPT INPUT
    if (c.gamemode == c.commercial and W_CheckNumForName(@constCast("map01")) < 0)
        return;

    while (eventtail != eventhead) : (eventtail = (1 + eventtail) % c.MAXEVENTS) {
        const ev = &events[eventtail];
        if (M_Responder(ev) != c.false)
            continue; // menu ate the event
        _ = G_Responder(ev);
    }
}

//
// D_Display
//  draw current display, possibly wiping it from the previous
//

// wipegamestate can be set to -1 to force a wipe on the next draw
pub export var wipegamestate: GameState = .DemoScreen;
extern var setsizeneeded: c.boolean;
extern var automapactive: c.boolean;
extern var menuactive: c.boolean;
extern var viewactive: c.boolean;
extern fn R_ExecuteSetViewSize() void;
extern fn R_RenderPlayerView(player: @TypeOf(&g_game.players[0])) void;

fn D_Display() void {
    const S = struct {
        var viewactivestate = false;
        var menuactivestate = false;
        var inhelpscreensstate = false;
        var fullscreen = false;
        var oldgamestate: GameState = .ForceRedraw;
        var borderdrawcount: c_int = 0;
    };

    if (g_game.nodrawers) {
        return; // for comparative timing / profiling
    }

    // change the view size if needed
    if (setsizeneeded != c.false) {
        R_ExecuteSetViewSize();
        S.oldgamestate = .ForceRedraw; // force background redraw
        S.borderdrawcount = 3;
    }

    // save the current screen if about to wipe
    var dowipe = false;
    if (g_game.gamestate != wipegamestate) {
        dowipe = true;
        wipe.StartScreen();
    }

    if (g_game.gamestate == .Level and g_game.gametic != 0) {
        HU_Erase();
    }

    // do buffered drawing
    switch (g_game.gamestate) {
        .Level => blk: {
            if (g_game.gametic == 0)
                break :blk;
            if (automapactive != c.false) {
                AM_Drawer();
            }
            const redrawsbar =
                dowipe
                or (c.viewheight != 200 and S.fullscreen)
                // just put away the help screen
                or S.inhelpscreensstate and inhelpscreens != c.true;
            ST_Drawer(c.viewheight == 200, redrawsbar);
            S.fullscreen = c.viewheight == 200;
        },

        .Intermission => WI_Drawer(),
        .Finale => F_Drawer(),
        .DemoScreen => D_PageDrawer(),

        .ForceWipe,
        .ForceRedraw => {},
    }

    // draw buffered stuff to screen
    I_UpdateNoBlit();

    // draw the view directly
    if (g_game.gamestate == .Level and automapactive == c.false and g_game.gametic != 0) {
        R_RenderPlayerView(&g_game.players[g_game.displayplayer]);
    }

    if (g_game.gamestate == .Level and g_game.gametic != 0) {
        HU_Drawer();
    }

    // clean up border stuff
    if (g_game.gamestate != S.oldgamestate and g_game.gamestate != .Level) {
        I_SetPalette(@ptrCast(W_CacheLumpName("PLAYPAL", .Cache)));
    }

    // see if the border needs to be initially drawn
    if (g_game.gamestate == .Level and S.oldgamestate != .Level) {
        S.viewactivestate = false; // view was not active
        R_FillBackScreen(); // draw the pattern into the back screen
    }

    // see if the border needs to be updated to the screen
    if (g_game.gamestate == .Level and automapactive == c.false and c.scaledviewwidth != 320) {
        if (menuactive != c.false or S.menuactivestate or !S.viewactivestate) {
            S.borderdrawcount = 3;
        }
        if (S.borderdrawcount != 0) {
            R_DrawViewBorder(); // erase old menu stuff
            S.borderdrawcount -= 1;
        }
    }

    S.menuactivestate = menuactive != c.false;
    S.viewactivestate = viewactive != c.false;
    S.inhelpscreensstate = inhelpscreens != c.false;
    wipegamestate = g_game.gamestate;
    S.oldgamestate = g_game.gamestate;

    // draw pause pic
    if (g_game.paused) {
        const y = if (automapactive != c.false) 4 else c.viewwindowy + 4;
        c.V_DrawPatchDirect(c.viewwindowx + @divTrunc(c.scaledviewwidth - 68, 2), y, 0, @ptrCast(@alignCast(W_CacheLumpName("M_PAUSE", .Cache))));
    }

    // menus go directly to the screen
    M_Drawer(); // menu is drawn even on top of everything
    NetUpdate(); // send out any new accumulation

    // normal update
    if (!dowipe) {
        I_FinishUpdate(); // page flip or blit buffer
        return;
    }

    // wipe update
    wipe.EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);

    var wipestart = I_GetTime() - 1;
    var done = false;

    while (!done) {
        var nowtime: c_int = undefined;
        var tics: c_int = 0;
        var i: usize = 0;
        while (tics == 0) {
            i += 1;
            nowtime = I_GetTime();
            tics = nowtime - wipestart;

            if (tics < 0) {
                @import("std").debug.print("!!! `tics` is negative: i={} nowtime={} wipestart={} tics={}\n", .{i, nowtime, wipestart, tics});
            }
        }
        wipestart = nowtime;
        done = wipe.ScreenWipe(.Melt, SCREENWIDTH, SCREENHEIGHT, @intCast(tics));
        I_UpdateNoBlit();
        M_Drawer(); // menu is drawn even on top of wipes
        I_FinishUpdate(); // page flip or blit buffer
    }
}

//
//  D_DoomLoop
//

fn D_DoomLoop() noreturn {
    if (g_game.demorecording) {
        G_BeginRecording();
    }

    // TODO: This parm check should be in `D_DoomMain()`
    if (M_CheckParm("-debugfile") != 0) {
        var buffer: [20]u8 = undefined;
        const filename = fmt.bufPrintZ(&buffer, "debug{}.txt", .{g_game.consoleplayer}) catch unreachable;
        const stdout = std.io.getStdOut().writer();
        stdout.print("debug output to: {s}\n", .{filename}) catch unreachable;
        debugfile = std.c.fopen(filename, "w");
    }

    I_InitGraphics();

    while (true) {
        // frame syncronous IO operations
        I_StartFrame();

        // process one or more tics
        if (singletics) {
            I_StartTic();
            D_ProcessEvents();
            G_BuildTiccmd(&d_net.netcmds[g_game.consoleplayer][@as(usize, @intCast(d_net.maketic)) % d_net.BACKUPTICS]);
            if (advancedemo) {
                D_DoAdvanceDemo();
            }
            M_Ticker();
            G_Ticker();
            g_game.gametic += 1;
            d_net.maketic += 1;
        } else {
            TryRunTics(); // will run at least one tic
        }

        c.S_UpdateSounds(g_game.players[g_game.consoleplayer].mo); // move positional sounds

        // Update display, next frame, with current state.
        D_Display();

        I_UpdateSound();
        I_SubmitSound();
    }
}

//
//  DEMO LOOP
//
var demosequence: usize = 0;
var pagetic: c_int = 0;
var pagename: [*:0]const u8 = undefined;

//
// D_PageTicker
// Handles timing for warped projection
//
pub fn D_PageTicker() void {
    pagetic -= 1;
    if (pagetic < 0) {
        D_AdvanceDemo();
    }
}

//
// D_PageDrawer
//
fn D_PageDrawer() void {
    c.V_DrawPatch(0, 0, 0, @ptrCast(@alignCast(W_CacheLumpName(pagename, .Cache))));
}

//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
pub fn D_AdvanceDemo() void {
    advancedemo = true;
}

//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
pub fn D_DoAdvanceDemo() void {
    g_game.players[g_game.consoleplayer].playerstate = c.PST_LIVE; // not reborn
    advancedemo = false;
    g_game.usergame = c.false; // no save / end game here
    g_game.paused = false;
    c.gameaction = c.ga_nothing;

    switch (demosequence) {
        0 => {
            pagetic = if (c.gamemode == c.commercial) 35 * 11 else 170;
            g_game.gamestate = .DemoScreen;
            pagename = "TITLEPIC";
            c.S_StartMusic(if (c.gamemode == c.commercial) c.mus_dm2ttl else c.mus_intro);
        },
        1 => {
            G_DeferedPlayDemo("demo1");
        },
        2 => {
            pagetic = 200;
            g_game.gamestate = .DemoScreen;
            pagename = "CREDIT";
        },
        3 => {
            G_DeferedPlayDemo("demo2");
        },
        4 => {
            g_game.gamestate = .DemoScreen;
            if (c.gamemode == c.commercial) {
                pagetic = 35 * 11;
                pagename = "TITLEPIC";
                c.S_StartMusic(c.mus_dm2ttl);
            } else {
                pagetic = 200;
                pagename = if (c.gamemode == c.retail) "CREDIT" else "HELP2";
            }
        },
        5 => {
            G_DeferedPlayDemo("demo3");
        },
        // THE DEFINITIVE DOOM Special Edition demo
        6 => {
            G_DeferedPlayDemo("demo4");
        },
        else => {}, // TODO: Make a zig enum and remove this else arm
    }

    demosequence += 1;
    demosequence %= if (c.gamemode == c.retail) 7 else 6;
}

//
// D_StartTitle
//
export fn D_StartTitle() void {
    c.gameaction = c.ga_nothing;
    demosequence = 0;
    D_AdvanceDemo();
}

//
// D_AddFile
//
fn D_AddFile(file: []const u8) void {
    numwadfiles += 1;

    if (numwadfiles == wadfiles.len) {
        I_Error("Too many wadfiles\n");
    }

    const newfile = std.heap.raw_c_allocator.dupe(u8, file) catch unreachable;
    wadfiles[numwadfiles - 1] = newfile;
}

//
// IdentifyVersion
// Checks availability of IWAD files by name,
// to determine whether registered/commercial features
// should be executed (notably loading PWAD's).
//
fn IdentifyVersion() void {
    var arena = std.heap.ArenaAllocator.init(std.heap.raw_c_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    const doomwaddir = os.getenv("DOOMWADDIR") orelse ".";

    // Commercial.
    const doom2wad = fmt.allocPrint(allocator, "{s}/doom2.wad", .{doomwaddir}) catch unreachable;

    // Retail.
    const doomuwad = fmt.allocPrint(allocator, "{s}/doomu.wad", .{doomwaddir}) catch unreachable;

    // Registered.
    const doomwad = fmt.allocPrint(allocator, "{s}/doom.wad", .{doomwaddir}) catch unreachable;

    // Shareware.
    const doom1wad = fmt.allocPrint(allocator, "{s}/doom1.wad", .{doomwaddir}) catch unreachable;

    const plutoniawad = fmt.allocPrint(allocator, "{s}/plutonia.wad", .{doomwaddir}) catch unreachable;

    const tntwad = fmt.allocPrint(allocator, "{s}/tnt.wad", .{doomwaddir}) catch unreachable;

    // French stuff.
    const doom2fwad = fmt.allocPrint(allocator, "{s}/doom2f.wad", .{doomwaddir}) catch unreachable;

    const home = os.getenv("HOME") orelse {
        I_Error("Please set $HOME to your home directory");
    };
    _ = fmt.bufPrintZ(&basedefault, "{s}/.doomrc", .{home}) catch unreachable;

    if (M_CheckParm("-shdev") != 0) {
        c.gamemode = c.shareware;
        devparm = c.true;
        D_AddFile(c.DEVDATA ++ "doom1.wad");
        D_AddFile(c.DEVMAPS ++ "data_se/texture1.lmp");
        D_AddFile(c.DEVMAPS ++ "data_se/pnames.lmp");
        _ = fmt.bufPrintZ(&basedefault, "{s}", .{c.DEVDATA ++ "default.cfg"}) catch unreachable;
        return;
    }

    if (M_CheckParm("-regdev") != 0) {
        c.gamemode = c.registered;
        devparm = c.true;
        D_AddFile(c.DEVDATA ++ "doom.wad");
        D_AddFile(c.DEVMAPS ++ "data_se/texture1.lmp");
        D_AddFile(c.DEVMAPS ++ "data_se/texture2.lmp");
        D_AddFile(c.DEVMAPS ++ "data_se/pnames.lmp");
        _ = fmt.bufPrintZ(&basedefault, "{s}", .{c.DEVDATA ++ "default.cfg"}) catch unreachable;
        return;
    }

    if (M_CheckParm("-comdev") != 0) {
        c.gamemode = c.commercial;
        devparm = c.true;
        D_AddFile(c.DEVDATA ++ "doom2.wad");

        D_AddFile(c.DEVMAPS ++ "cdata/texture1.lmp");
        D_AddFile(c.DEVMAPS ++ "cdata/pnames.lmp");
        _ = fmt.bufPrintZ(&basedefault, "{s}", .{c.DEVDATA ++ "default.cfg"}) catch unreachable;
        return;
    }

    const stdout = std.io.getStdOut().writer();

    if (os.access(doom2fwad, os.R_OK)) {
        c.gamemode = c.commercial;
        // C'est ridicule!
        // Let's handle languages in config files, okay?
        c.language = c.french;
        stdout.print("French version\n", .{}) catch unreachable;
        D_AddFile(doom2fwad);
        return;
    } else |_| {}

    if (os.access(doom2wad, os.R_OK)) {
        c.gamemode = c.commercial;
        D_AddFile(doom2wad);
        return;
    } else |_| {}

    if (os.access(plutoniawad, os.R_OK)) {
        c.gamemode = c.commercial;
        D_AddFile(plutoniawad);
        return;
    } else |_| {}

    if (os.access(tntwad, os.R_OK)) {
        c.gamemode = c.commercial;
        D_AddFile(tntwad);
        return;
    } else |_| {}

    if (os.access(doomuwad, os.R_OK)) {
        c.gamemode = c.retail;
        D_AddFile(doomuwad);
        return;
    } else |_| {}

    if (os.access(doomwad, os.R_OK)) {
        c.gamemode = c.registered;
        D_AddFile(doomwad);
        return;
    } else |_| {}

    if (os.access(doom1wad, os.R_OK)) {
        c.gamemode = c.shareware;
        D_AddFile(doom1wad);
        return;
    } else |_| {}

    stdout.print("Game mode indeterminate.\n", .{}) catch unreachable;
    c.gamemode = c.indetermined;

    // We don't abort. Let's see what the PWAD contains.
    //exit(1);
    //I_Error ("Game mode indeterminate\n");
}

//
// Find a Response File
//

// TODO: Use `myargs` instead once safe to do so.
extern var myargc: c_int;
extern var myargv: [*c][*c]u8;

fn FindResponseFile() void {
    const stdout = std.io.getStdOut().writer();
    const MAXARGVS = 100;

    for (1..@intCast(myargc)) |i| {
        if (myargv[i][0] == '@') {
            // TODO: Extract this body to a func in m_argv.zig
            // (and, of course, make it more zig idiomatic)

            // READ THE RESPONSE FILE INTO MEMORY
            const responsefile = std.mem.span(myargv[i] + 1);
            const handle = os.open(responsefile, os.O.RDONLY, 0) catch {
                I_Error("\nNo such response file!");
            };
            stdout.print("Found response file {s}!\n", .{responsefile}) catch unreachable;
            const size = (os.fstat(handle) catch unreachable).size;
            const file = std.heap.raw_c_allocator.alloc(u8, @intCast(size)) catch unreachable;
            _ = os.read(handle, file) catch unreachable;
            os.close(handle);

            // KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG
            const originalargv = myargv;

            // TODO: assign to `myargs`
            myargv = (std.heap.raw_c_allocator.alloc([*c]u8, MAXARGVS) catch unreachable).ptr;
            @memset(myargv[0 .. MAXARGVS - 1], 0);

            const infile = @as([*]u8, @ptrCast(file));
            var indexinfile: usize = 0;

            while (indexinfile < i) : (indexinfile += 1) {
                myargv[indexinfile] = originalargv[indexinfile];
            }

            var k: usize = 0;
            while (k < size) {
                myargv[indexinfile] = infile + k;
                indexinfile += 1;

                while (k < size and (infile[k] >= ' ' + 1 and infile[k] <= 'z')) {
                    k += 1;
                }
                infile[k] = 0;
                while (k < size and (infile[k] <= ' ' or infile[k] > 'z')) {
                    k += 1;
                }
            }

            k = i + 1;
            while (k < myargc) : ({
                k += 1;
                indexinfile += 1;
            }) {
                myargv[indexinfile] = originalargv[k];
            }
            myargc = @intCast(indexinfile);

            // DISPLAY ARGS
            stdout.print("{} command-line args:\n", .{myargc - 1}) catch unreachable;
            k = 1;
            while (k < myargc) : (k += 1) {
                stdout.print("{s}\n", .{myargv[k]}) catch unreachable;
            }

            break;
        }
    }
}

//
// D_DoomMain
//
extern var modifiedgame: c.boolean;
extern var forwardmove: [2]c_int;
extern var sidemove: [2]c_int;
extern var statcopy: *anyopaque;
extern var singledemo: c.boolean;

extern fn V_Init() void;
extern fn Z_Init() void;
extern fn M_Init() void;
extern fn R_Init() void;
extern fn P_Init() void;
extern fn S_Init(sfxVolume: c_int, musicVolume: c_int) void;
extern fn HU_Init() void;
const ST_Init = @import("st_stuff.zig").ST_Init;

pub fn toDoomBoolean(b: bool) c.boolean {
    return if (b) c.true else c.false;
}

pub fn D_DoomMain() noreturn {
    FindResponseFile();

    IdentifyVersion();

    modifiedgame = c.false;

    nomonsters = toDoomBoolean(M_CheckParm("-nomonsters") != 0);
    respawnparm = M_CheckParm("-respawn") != 0;
    fastparm = toDoomBoolean(M_CheckParm("-fast") != 0);
    devparm = toDoomBoolean(M_CheckParm("-devparm") != 0);
    if (M_CheckParm("-altdeath") != 0) {
        g_game.deathmatch = 2;
    } else if (M_CheckParm("-deathmatch") != 0) {
        g_game.deathmatch = 1;
    }

    const title = switch (c.gamemode) {
        c.retail => fmt.comptimePrint("                         " ++
            "The Ultimate DOOM Startup v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
        c.shareware => fmt.comptimePrint("                            " ++
            "DOOM Shareware Startup v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
        c.registered => fmt.comptimePrint("                            " ++
            "DOOM Registered Startup v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
        c.commercial => fmt.comptimePrint("                         " ++
            "DOOM 2: Hell on Earth v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
        else => fmt.comptimePrint("                     " ++
            "Public DOOM - v{}.{}" ++
            "                           ", .{ c.VERSION / 100, c.VERSION % 100 }),
    };

    const stdout = std.io.getStdOut().writer();
    stdout.print("{s}\n", .{title}) catch unreachable;

    if (devparm != c.false) {
        stdout.print("{s}", .{c.D_DEVSTR}) catch unreachable;
    }

    if (M_CheckParm("-cdrom") != 0) {
        stdout.print("{s}", .{c.D_CDROM}) catch unreachable;
        std.fs.makeDirAbsolute("c:\\doomdata") catch unreachable;
        _ = fmt.bufPrintZ(&basedefault, "{s}", .{"c:/doomdata/default.cfg"}) catch unreachable;
    }

    // turbo option
    var p = @as(usize, @intCast(M_CheckParm("-turbo")));
    if (p != 0) {
        var scale: usize = 200;

        if (p < myargc - 1) {
            scale = fmt.parseInt(usize, std.mem.span(myargv[p + 1]), 10) catch 0;
        }
        if (scale < 10) {
            scale = 10;
        }
        if (scale > 400) {
            scale = 400;
        }
        stdout.print("turbo scale: {}%\n", .{scale}) catch unreachable;
        forwardmove[0] = forwardmove[0] * @as(c_int, @intCast(scale / 100));
        forwardmove[1] = forwardmove[1] * @as(c_int, @intCast(scale / 100));
        sidemove[0] = sidemove[0] * @as(c_int, @intCast(scale / 100));
        sidemove[1] = sidemove[1] * @as(c_int, @intCast(scale / 100));
    }

    var filebuf: [256]u8 = undefined;

    // add any files specified on the command line with -file wadfile
    // to the wad list
    //
    // convenience hack to allow -wart e m to add a wad file
    // prepend a tilde to the filename so wadfile will be reloadable
    p = @intCast(M_CheckParm("-wart"));
    if (p != 0) {
        myargv[p][4] = 'p'; // big hack, change to -warp

        var file: []u8 = undefined;
        // Map name handling.
        switch (c.gamemode) {
            c.shareware, c.retail, c.registered => {
                file = fmt.bufPrint(&filebuf, "~" ++ c.DEVMAPS ++ "E{}M{}.wad", .{myargv[p + 1][0], myargv[p + 2][0]}) catch unreachable;
                stdout.print("Warping to Episode {s}, Map {s}.\n", .{myargv[p + 1], myargv[p + 2]}) catch unreachable;
            },

            // c.commercial,
            else => {
                const num = fmt.parseInt(usize, std.mem.span(myargv[p + 1]), 10) catch 0;
                if (num < 10) {
                    file = fmt.bufPrint(&filebuf, "~" ++ c.DEVMAPS ++ "cdata/map0{}.wad", .{num}) catch unreachable;
                } else {
                    file = fmt.bufPrint(&filebuf, "~" ++ c.DEVMAPS ++ "cdata/map{}.wad", .{num}) catch unreachable;
                }
            },
        }
        D_AddFile(file);
    }

    p = @intCast(M_CheckParm("-file"));
    if (p != 0) {
        // the parms after p are wadfile/lump names,
        // until end of parms or another - preceded parm
        modifiedgame = c.true; // homebrew levels
        p += 1;
        while (p != myargc and myargv[p][0] != '-') : (p += 1) {
            D_AddFile(std.mem.span(myargv[p]));
        }
    }

    p = @intCast(M_CheckParm("-playdemo"));

    if (p == 0) {
        p = @intCast(M_CheckParm("-timedemo"));
    }

    if (p != 0 and p < myargc - 1) {
        const file = fmt.bufPrint(&filebuf, "{s}.lmp", .{myargv[p + 1]}) catch unreachable;
        D_AddFile(file);
        stdout.print("Playing demo {s}.lmp.\n", .{myargv[p + 1]}) catch unreachable;
    }

    // get skill / episode / map from parms
    startskill = .Medium;
    startepisode = 1;
    startmap = 1;
    autostart = false;

    p = @intCast(M_CheckParm("-skill"));
    if (p != 0 and p < myargc - 1) {
        startskill = @enumFromInt(myargv[p + 1][0] - '1');
        autostart = true;
    }

    p = @intCast(M_CheckParm("-episode"));
    if (p != 0 and p < myargc - 1) {
        startepisode = myargv[p + 1][0] - '0';
        startmap = 1;
        autostart = true;
    }

    p = @intCast(M_CheckParm("-timer"));
    if (p != 0 and p < myargc - 1 and g_game.deathmatch != 0) {
        const time = fmt.parseInt(usize, std.mem.span(myargv[p + 1]), 10) catch 0;
        stdout.print("Levels will end after {} minute", .{time}) catch unreachable;
        if (time > 1)
            stdout.print("s", .{}) catch unreachable;
        stdout.print(".\n", .{}) catch unreachable;
    }

    p = @intCast(M_CheckParm("-avg"));
    if (p != 0 and p < myargc - 1 and g_game.deathmatch != 0) {
        stdout.print("Austin Virtual Gaming: Levels will end after 20 minutes\n", .{}) catch unreachable;
    }

    p = @intCast(M_CheckParm("-warp"));
    if (p != 0 and p < myargc - 1) {
        if (c.gamemode == c.commercial) {
            startmap = fmt.parseInt(c_int, std.mem.span(myargv[p + 1]), 10) catch 0;
        } else {
            startepisode = myargv[p + 1][0] - '0';
            startmap = myargv[p + 2][0] - '0';
        }
        autostart = true;
    }

    // init subsystems
    stdout.print("V_Init: allocate screens.\n", .{}) catch unreachable;
    V_Init();

    stdout.print("M_LoadDefaults: Load system defaults.\n", .{}) catch unreachable;
    M_LoadDefaults(); // load before initing other systems

    stdout.print("Z_Init: Init zone memory allocation daemon. \n", .{}) catch unreachable;
    Z_Init();

    stdout.print("W_Init: Init WADfiles.\n", .{}) catch unreachable;
    W_InitMultipleFiles(wadfiles[0..numwadfiles]);

    // Check for -file in shareware
    if (modifiedgame != c.false) {
        // These are the lumps that will be checked in IWAD,
        // if any one is not present, execution will be aborted.
        var names = [_][:0]const u8{ "e2m1", "e2m2", "e2m3", "e2m4", "e2m5", "e2m6", "e2m7", "e2m8", "e2m9", "e3m1", "e3m3", "e3m3", "e3m4", "e3m5", "e3m6", "e3m7", "e3m8", "e3m9", "dphoof", "bfgga0", "heada1", "cybra1", "spida1d1" };

        if (c.gamemode == c.shareware) {
            I_Error("\nYou cannot -file with the shareware version. Register!");
        }

        // Check for fake IWAD with right name,
        // but w/o all the lumps of the registered version.
        if (c.gamemode == c.registered) {
            var i: usize = 0;
            _ = i;
            for (names) |name| {
                if (W_CheckNumForName(name) < 0) {
                    I_Error("\nThis is not the registered version.");
                }
            }
        }
    }

    // Iff additonal PWAD files are used, print modified banner
    if (modifiedgame != c.false) {
        stdout.print("===========================================================================\n" ++
            "ATTENTION:  This version of DOOM has been modified.  If you would like to\n" ++
            "get a copy of the original game, call 1-800-IDGAMES or see the readme file.\n" ++
            "        You will not receive technical support for modified games.\n" ++
            "                      press enter to continue\n" ++
            "===========================================================================\n", .{}) catch unreachable;
        _ = c.getchar();
    }

    // Check and print which version is executed.
    switch (c.gamemode) {
        c.shareware, c.indetermined => {
            stdout.print("===========================================================================\n" ++
                "                                Shareware!\n" ++
                "===========================================================================\n", .{}) catch unreachable;
        },
        c.registered, c.retail, c.commercial => {
            stdout.print("===========================================================================\n" ++
                "                 Commercial product - do not distribute!\n" ++
                "         Please report software piracy to the SPA: 1-800-388-PIR8\n" ++
                "===========================================================================\n", .{}) catch unreachable;
        },

        else => unreachable,
    }

    stdout.print("M_Init: Init miscellaneous info.\n", .{}) catch unreachable;
    M_Init();

    stdout.print("R_Init: Init DOOM refresh daemon - ", .{}) catch unreachable;
    R_Init();

    stdout.print("\nP_Init: Init Playloop state.\n", .{}) catch unreachable;
    P_Init();

    stdout.print("I_Init: Setting up machine state.\n", .{}) catch unreachable;
    I_Init();

    stdout.print("D_CheckNetGame: Checking network game status.\n", .{}) catch unreachable;
    D_CheckNetGame();

    stdout.print("S_Init: Setting up sound.\n", .{}) catch unreachable;
    S_Init(c.snd_SfxVolume, c.snd_MusicVolume);

    stdout.print("HU_Init: Setting up heads up display.\n", .{}) catch unreachable;
    HU_Init();

    stdout.print("ST_Init: Init status bar.\n", .{}) catch unreachable;
    ST_Init();

    // check for a driver that wants intermission stats
    p = @intCast(M_CheckParm("-statcopy"));
    if (p != 0 and p < myargc - 1) {
        // for statistics driver
        statcopy = @ptrFromInt(fmt.parseInt(usize, std.mem.span(myargv[p + 1]), 0) catch 0);
        stdout.print("External statistics registered.\n", .{}) catch unreachable;
    }

    // start the apropriate game based on parms
    p = @intCast(M_CheckParm("-record"));

    if (p != 0 and p < myargc - 1) {
        G_RecordDemo(std.mem.span(myargv[p + 1]));
        autostart = true;
    }

    p = @intCast(M_CheckParm("-playdemo"));
    if (p != 0 and p < myargc - 1) {
        singledemo = c.true; // quit after one demo
        G_DeferedPlayDemo(myargv[p + 1]);
        D_DoomLoop(); // never returns
    }

    p = @intCast(M_CheckParm("-timedemo"));
    if (p != 0 and p < myargc - 1) {
        G_TimeDemo(myargv[p + 1]);
        D_DoomLoop(); // never returns
    }

    p = @intCast(M_CheckParm("-loadgame"));
    if (p != 0 and p < myargc - 1) {
        const file =
            if (M_CheckParm("-cdrom") != 0)
                fmt.bufPrintZ(&filebuf, "c:\\doomdata\\" ++ c.SAVEGAMENAME ++ "{}.dsg", .{myargv[p + 1][0]}) catch unreachable
            else
                fmt.bufPrintZ(&filebuf, c.SAVEGAMENAME ++ "{}.dsg", .{myargv[p + 1][0]}) catch unreachable;
        G_LoadGame(file);
    }

    if (c.gameaction != c.ga_loadgame) {
        if (autostart or c.netgame != 0) {
            G_InitNew(startskill, startepisode, startmap);
        } else {
            D_StartTitle(); // start up intro loop
        }
    }

    D_DoomLoop(); // never returns
}
